using PodNet.EnumValues.Generator.Models;
using PodNet.EnumValues.Integrals;
using System.Text;

namespace PodNet.EnumValues.Generator;

public sealed class ExtensionCodeBuilder(ExtensionToGenerate extension, CancellationToken cancellationToken)
{
    private readonly EnumInfo @enum = extension.EnumInfo;
    private readonly string accessibility = extension.Accessibility switch
    {
        Accessibility.Internal => "internal",
        Accessibility.Public or _ => "public"
    };
    private readonly CancellationToken cancellationToken = cancellationToken;
    private readonly bool throwWhenMissing = extension.MissingValueHandling is MissingValueHandling.ThrowMissingValueException && extension.ValueCases.Any(v => v.Value is null);
    private readonly bool throwWhenUndefined = extension.UndefinedValueHandling is UndefinedValueHandling.ThrowMissingValueException;

    private void ThrowIfCancellationRequested() => cancellationToken.ThrowIfCancellationRequested();

    public string Build()
    {
        ThrowIfCancellationRequested();
        var sourceBuilder = new StringBuilder(2000 + (extension.ValueCases.Values.Length * 200));

        WriteHeader(sourceBuilder);
        WriteExtensionClass(sourceBuilder);
        WriteFooter(sourceBuilder);

        ThrowIfCancellationRequested();
        return sourceBuilder.ToString();
    }

    private void WriteHeader(StringBuilder sourceBuilder)
    {
        sourceBuilder.AppendLine($"""
                // <auto-generated />
                #nullable enable
                
                using PodNet.EnumValues;
                """);

        if (!string.IsNullOrWhiteSpace(@enum.Namespace) && @enum.Namespace != extension.Namespace)
            sourceBuilder.AppendLine($"using {@enum.Namespace};");

        sourceBuilder.AppendLine();

        if (!string.IsNullOrWhiteSpace(extension.Namespace))
            sourceBuilder.AppendLine($"namespace {extension.Namespace};");
    }

    private void WriteExtensionClass(StringBuilder sourceBuilder)
    {
        sourceBuilder.AppendLine($$"""
                {{accessibility}} static partial class {{extension.ClassName}}
                {
                """);

        ThrowIfCancellationRequested();

        WriteExtensionXmlDocumentation(sourceBuilder);

        if (!extension.IsFlags)
            WriteExtensionMethod(sourceBuilder);
        else
            WriteFlagsExtensionMethod(sourceBuilder);

        sourceBuilder.AppendLine($$"""
                }
                """);
    }

    private void WriteExtensionXmlDocumentation(StringBuilder sourceBuilder)
    {
        sourceBuilder.AppendLine($"""
                    /// <summary>
                    /// Gets the associated <see cref="{extension.ValueMarkerAttributeTypeName}"/> {(extension.IsFlags ? "flag values for each individual flag, concatenated using <paramref name=\"separator\"/>" : "value")} for the <see cref="{@enum.Identifier}"/> as follows:
                    /// <code>
                """);

        var maxIdentifierLength = extension.ValueCases.Select(v => v.Identifier.Length).DefaultIfEmpty(1).Max();
        var maxConstantValueLength = extension.ValueCases.Select(v => v.ConstantValue?.ToString().Length ?? 1).DefaultIfEmpty(1).Max();

        var (one, two) = extension.IsFlags &&
            extension.ValueCases.Values.Where(v => v.Value is not null && v.ConstantValue is not null && !IntegralValues.IsZeroEnumValue(v.ConstantValue)).Take(2).ToArray() is [var o, var t] ? (o, t) : default;
        if (extension.IsFlags && (one, two) is ({ }, { }))
        {
            maxIdentifierLength = Math.Max(maxIdentifierLength, one.Identifier.Length + two.Identifier.Length + 9);
            maxConstantValueLength = Math.Max(maxConstantValueLength, (one.ConstantValue?.ToString()?.Length ?? 0) + (two.ConstantValue?.ToString()?.Length ?? 0) + 9);
        }

        foreach (var valueCase in extension.ValueCases)
        {
            sourceBuilder.AppendLine($"""    /// {"".PadLeft(maxIdentifierLength - valueCase.Identifier.Length)}[{valueCase.Identifier}] = {(valueCase.ConstantValue?.ToString() ?? "").PadRight(maxConstantValueLength)} => {(string.IsNullOrWhiteSpace(valueCase.Value) ? extension.MissingValueHandling switch
            {
                MissingValueHandling.ThrowMissingValueException => $"💥 {nameof(MissingEnumValueException)} 💥",
                _ => $"\"{valueCase.Value}\"",
            } : $"\"{valueCase.Value}\"")}""");
        }

        if (extension.IsFlags && (one, two) is ({ }, { }))
            sourceBuilder.AppendLine($$"""
                    ///
                    /// {{$"[{one.Identifier} | {two.Identifier} | ...] = {one.ConstantValue} + {two.ConstantValue} + ...".PadLeft(maxIdentifierLength + maxConstantValueLength + 1)}} => "{{one.Value}}{{extension.FlagsSeparator}}{{two.Value}}{{extension.FlagsSeparator}}..."
                """);

        sourceBuilder.AppendLine($$"""
                ///
                /// {{$"[({@enum.UnderlyingType}){(extension.IsFlags ? "&lt;flag&gt;" : "")}]".PadLeft(maxIdentifierLength + maxConstantValueLength + 5)}} => {{extension.UndefinedValueHandling switch
        {
            UndefinedValueHandling.RawValueToString => $"$\"{{({@enum.UnderlyingType})}}\"",
            UndefinedValueHandling.EmptyString => "\"\"",
            UndefinedValueHandling.ThrowMissingValueException => $"💥 {nameof(MissingEnumValueException)} 💥",
            _ => throw new InvalidOperationException($"Invalid {nameof(UndefinedValueHandling)} value: {extension.UndefinedValueHandling}")
        }}}
            """);

        sourceBuilder.AppendLine($"""
                    /// </code>
                    /// </summary>
                    /// <remarks>Uses <see cref="{nameof(UndefinedValueHandling)}.{extension.UndefinedValueHandling}"/> for undefined values{(throwWhenMissing ? $""" and <see cref="{nameof(MissingValueHandling)}.{extension.MissingValueHandling}"/> for missing values""" : "")}.</remarks>
                    /// <param name="value">The <see cref="{@enum.Identifier}"/> value.</param>
                    /// <returns>A constant, deterministic string value representing the given <paramref name="value"/>.</returns>
                """);

        if (throwWhenMissing || throwWhenUndefined)
            sourceBuilder.AppendLine($"""
                    /// <exception cref="{nameof(MissingEnumValueException)}">Thrown when the provided <paramref name="value"/> {(extension.IsFlags ? "has a binary flag" : "is")} {(throwWhenMissing ? $"declared as a named enum member but has no corresponding marker attribute of type <see cref=\"{extension.ValueMarkerAttributeTypeName}\"/> assigned to it" : "")}{(throwWhenMissing && throwWhenUndefined ? " or is " : "")}{(throwWhenUndefined ? "not declared as a named enum member" : "")}.</exception>
                """);

        if (extension.IsFlags && extension.EnumInfo.CanBeNegative)
            sourceBuilder.AppendLine($"""
                    /// Type: {extension.EnumInfo.UnderlyingType}
                    /// <exception cref="{nameof(ArgumentOutOfRangeException)}">Thrown when the provided <paramref name="value"/> is negative and has no corresponding [<see cref="{extension.ValueMarkerAttributeTypeName}"/>] defined to it.</exception>
                """);
    }

    private void WriteExtensionMethod(StringBuilder sourceBuilder)
    {
        sourceBuilder.AppendLine($$"""
                    {{accessibility}} static string {{extension.MethodName}}(this {{@enum.Identifier}} value)
                """);

        WriteSwitch(sourceBuilder);
    }

    private void WriteSwitch(StringBuilder sourceBuilder)
    {
        sourceBuilder.AppendLine($$"""
                        => value switch
                        {
                """);

        WriteCases(sourceBuilder);

        WriteDefaultCase(sourceBuilder);

        sourceBuilder.AppendLine($$"""
                        };
                """);
    }

    private void WriteCases(StringBuilder sourceBuilder)
    {
        foreach (var valueCase in extension.ValueCases)
        {
            sourceBuilder.AppendLine($"""
                            {@enum.Identifier}.{valueCase.Identifier} => {GetCaseBody()}
                """);

            string GetCaseBody() => valueCase.Value switch
            {
                not null => $"\"{valueCase.Value}\",",
                null => $"throw new {nameof(MissingEnumValueException)}(typeof({@enum.Identifier}), value),"
            };
        }
    }

    private void WriteDefaultCase(StringBuilder sourceBuilder)
    {
        sourceBuilder.AppendLine($$"""
                            _ => {{extension.UndefinedValueHandling switch
        {
            UndefinedValueHandling.RawValueToString => $"$\"{{(({@enum.UnderlyingType})value)}}\"",
            UndefinedValueHandling.EmptyString => "\"\"",
            UndefinedValueHandling.ThrowMissingValueException => $"throw new {nameof(MissingEnumValueException)}(typeof({@enum.Identifier}), value)",
            _ => throw new InvalidOperationException($"Invalid {nameof(UndefinedValueHandling)} value: {extension.UndefinedValueHandling}")
        }}}
                """);
    }

    private void WriteFlagsExtensionMethod(StringBuilder sourceBuilder)
    {
        var zeroValue = extension.ValueCases.FirstOrDefault(c => c.ConstantValue is 0);

        sourceBuilder.AppendLine($$"""
                    {{accessibility}} static string {{extension.MethodName}}(this {{@enum.Identifier}} value, string? separator = "{{extension.FlagsSeparator}}")
                    {
                        var iValue = ({{@enum.UnderlyingType}})value;
                        if ((separator == "{{extension.FlagsSeparator}}" || ((iValue & (iValue - 1))) == 0) && GetSingleFlagValueOrNull(value) is { } shortCircuitStringValue)
                            return shortCircuitStringValue;
                """);

        if (@enum.CanBeNegative)
            sourceBuilder.AppendLine($$"""
                        if (iValue < 0)
                            throw new ArgumentOutOfRangeException(nameof(value), value, "Enum value was negative.");
                """);

        sourceBuilder.AppendLine($$"""
                        if (iValue == 0)
                            {{(zeroValue, extension.UndefinedValueHandling) switch
        {
            (null, UndefinedValueHandling.RawValueToString) => """return "0";""",
            (null, UndefinedValueHandling.EmptyString) => """return "";""",
            ({ Value: { } zero }, _) => $"""return "{zero}";""",
            ({ Value: null }, _) or (null, UndefinedValueHandling.ThrowMissingValueException) => $"throw new {nameof(MissingEnumValueException)}(typeof({@enum.Identifier}), value);",
            _ => throw new InvalidOperationException($"Invalid {nameof(UndefinedValueHandling)} value: {extension.UndefinedValueHandling}")
        }}}
                        var flags = new System.Text.StringBuilder();
                        var hasSeparator = !string.IsNullOrEmpty(separator);
                        for ({{@enum.UnderlyingType}} i = 1; i <= iValue; i *= 2)
                        {
                            if ((i & iValue) != 0)
                            {
                                if (GetSingleFlagValueOrNull(({{@enum.Identifier}})i) is { } stringValue)
                                    flags.Append(stringValue);
                                else
                                    {{extension.UndefinedValueHandling switch
        {
            UndefinedValueHandling.RawValueToString => $$"""flags.Append(i);""",
            UndefinedValueHandling.EmptyString => """flags.Append("");""",
            UndefinedValueHandling.ThrowMissingValueException => $"throw new {nameof(MissingEnumValueException)}(typeof({@enum.Identifier}), ({@enum.Identifier})i);",
            _ => throw new InvalidOperationException($"Invalid {nameof(UndefinedValueHandling)} value: {extension.UndefinedValueHandling}")
        }}}
                                if (hasSeparator)
                                    flags.Append(separator);
                            }
                        }
                        if (hasSeparator && flags.Length > 1)
                            flags.Remove(flags.Length - 1, 1);
                        return flags.ToString();

                        static string? GetSingleFlagValueOrNull({{@enum.Identifier}} value) => value switch
                        {
                """);

        WriteCases(sourceBuilder);

        sourceBuilder.AppendLine("""
                            _ => null
                        };
                    }
                """);
    }

    private void WriteFooter(StringBuilder sourceBuilder)
    {
        sourceBuilder.AppendLine("""
                #nullable restore
                """);
    }
}
